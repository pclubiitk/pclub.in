---
layout: post
title: "Getting Started with PClub"
date: 2020-12-02 19:44:00 +0530
author: Priydarshi Singh
website: https://dryairship.github.io
category: events
tags:
- programming
categories:
- events

image:
  url: /images/pclublogo.png
---

### Programming 101

This would hopefully turn out to be a comprehensive guide to someone starting as a newbie in this vast world of programming. Here, we would like to give some personalized inputs on the generalized procedure of getting started. We will also assume that you all are well versed with using a computer.

**Note:** If you have done programming before, you may wish to skip the first few sections.

#### **Text Editors**

I am pretty sure, most of you must have had some experience using Notepad at some point in your life and would be thinking of using it for writing computer programs as well. While there is as such no big problem in using Notepad for writing the code, but soon it will make your life very hard. Here are some reasons why,

*   **No Syntax Highlighting:** Notepad doesn't provide you with the feature of syntax highlighting and this is one of the biggest problems with vanilla Notepad. Visualizing reserved words with different colors helps a lot as you will end up making a lot fewer mistakes. It will save your life from getting miserable, debugging (removing logical and syntactical errors) your code the whole time.
*   **No Autocomplete:** Modern text editors come with the feature of autocomplete or if not, they have the functionality to install required plugins or extensions for the same. This feature allows you to autocomplete the variable names and reserved words. This will help in saving a lot of time and also making the code less erroneous.
*   **No Formatting of code:** Notepad lacks the functionality of auto indenting the code for you. Auto indenting makes the code more readable and easy to understand. It also helps in visualizing the flow of execution of the program. Lack of indentation will lead to making your code less readable and hence, debugging it highly difficult.

I hope the above reasons were convincing enough to make you switch to a better text editor. We recommend using any one amongst [Sublime Text](https://www.sublimetext.com/) or [VS Code](https://code.visualstudio.com/), or a dedicated IDE(Integrated Development Environment) for that language.

We have written another blog on [How to get Started with Sublime Text in Windows For Competitive Programming](https://medium.com/programming-club-iit-kanpur/gearing-up-for-competitive-programming-86833f2325fb). Do read it for a practical walk-through.

### What everyone should know in today’s world.

We provide a comprehensive list of to-dos. This list is not exhaustive; instead, it can be manipulated by the reader according to their interests and what they like among the below-mentioned points.

#### **Choosing your first programming language**

After all the setup told above, it’s finally time to start coding! But wait, there are so many languages out there, which one to choose? We know that it might get confusing to choose a particular programming language, to begin with. There are various arguments in favor of different languages and we think a good first programming language should have the following characteristics:

*   It should be **relevant** today. The programming languages like BASIC or any of its sisters that you might have learned about in school are not much in usage today.
*   It should be easy to set up without much extensive work.
*   It should be simple to learn. (**Note:** We are not asking you to master it as it takes a lot of time to master a language.)

That being said, these are our recommendations:

**C/C++—** These languages form the basis of modern languages like Python and Julia. They carry immense speed and control over your operations too. Although that kind of control won’t be needed in our day-to-day tasks, we suggest one should learn either one of these to make a strong base for coding. The best resource we have ever obtained is IIT Kanpur’s ESC101A course material itself. It can be found [here](https://www.cse.iitk.ac.in/users/nsrivast/esc101.html) at Prof. Nisheeth’s website. It starts right from the fact assuming you don’t know anything about programming.

**Python —** Python is like talking to a computer in a human’s language. It is much more human-readable than C/C++, which makes it the most popular language in the world. “[**Learn Python the Hard Way**](https://drive.google.com/file/d/1YQ5e8GOKOBaXYdB0yz0eKW1QaLuC4f4D/view?usp=sharing)” by Zed Shaw provides one of the most comprehensive guides to Python. It will hardly take a few hours to complete the book, and we suggest you have Python 3.x.x installed (refer to [this](https://www.python.org/downloads/) link for installation) and have the interpreter (refer to [this](https://docs.python.org/3/tutorial/interpreter.html) link) running while you read the book so that you execute the code and experiment with the language as you learn.

**JavaScript —** It is extremely relevant in today’s world, especially in the field of web development. Though JavaScript is a little slower than C/C++, JavaScript is indeed a very powerful language, and most of the modern websites are built using its frameworks. [This](https://www.tutorialspoint.com/javascript/index.htm) is a pretty good resource to get started with this language.

**Bash —** Bash is one of the most popular shell scripting languages. It is the default shell for most Linux distributions out there, and we programmers are addicted to Linux! If you don’t know what is Linux, it is an operating system used by all programmers. If you ever remember scenes from movies (The Matrix, how can one forget this) showing the person hacking a computer with lots-and-lots of green-colored text, don’t worry, you are going to get it all here in Linux! This may not be needed at the moment, but learning is always a plus-point, and who knows we may keep a super-cool session on exploring Bash scripting sometime in the future? This [resource](https://www.tutorialspoint.com/unix/unix-getting-started.htm) is a perfect place to start with.

### Competitive Programming — A Modern Sport

Prerequisites to understand this section: Some idea about what a computer program is, input, output, variables, etc.

![](/images/1__Y0ppgbdAbGkF88YlLDR__CA.png)

As you explore the world of coding, you see people who can come up with ideas quickly and type a piece of the script right away to solve a given puzzle or problem.

This forms the core of _competitive programming,_ where you are presented with computational puzzles. They are often presented as a small story having some context, where you are expected to code a program that can give the answer to the puzzle as quickly and as efficiently as possible. You would certainly like this domain if you get high solving puzzles!

As all major companies all over the world need people with good problem-solving skills, competitive programming becomes a _gym_ to sharpen your mind and showcase your skills on a global platform!

Let us take a simple problem from [Codeforces](https://codeforces.com) —

![](/images/1__HoJx9DEE3qqNhY553jtodA.png)

See the above problem, for instance. There is a problem statement, and there is a prescribed input and output format. Your program must follow the specified formats. Try working out the problem for the sample input. Basically, for all possible input in the range given, your program should generate some output.

Your program gets accepted when your output matches the output of the solution program written by the problem setter and tester! Note that your programs may be completely different, but if you have solved the problem correctly, the output must match!

Obviously, you need to be able to write a program in some language. C/C++, Python, Java are popular choices, and you are taught C in ESC101.

A good idea for a beginner is to learn the basics of a language and understand the fundamentals. As you gradually write more and more code, it becomes easier to transform your ideas into code, and the typing part becomes routine!

When you put your logic or solution into code, you have _implemented_ an _algorithm_. Sometimes, you use some data structures such as _arrays, trees, set, map queue,_ etc. Don’t worry if you aren’t familiar with **data structures —** They are containers to store _variables_ in some meaningful way so that you can retrieve them or their properties later efficiently. ESC101 will expose you to some basic data structures!

As for **algorithms,** they are basically the steps to reach your goal. Suppose you want the biggest number from a list of numbers — You go through each number in the list and ask yourself if it is the biggest number you have seen till now? If so, remember it. And go on. In the end, you will have the biggest number on the list.

![](/images/1__xolj9Zsil49u4VUPRTVZNQ.png)

Assuming your basics are good enough, to get started, you can create accounts on various _online judges._ **Online judges** are the websites that have problems and checkers, which will run your program on their servers. They have specially designed test cases to check whether your program gives the correct output!

Codeforces, Codechef, Atcoder, TopCoder, Hackerrank, etc. are popular online judges. You can join Codeforces where we have a CP [group](https://codeforces.com/group/Y09cKsRBX7/blog) managed by PClub where interested students compete among themselves to be the S[port Programmer of the Month](https://docs.google.com/spreadsheets/d/1Vot8qeWoePLobVTuPvfBi_G-oECfj22Qr6hxVA9cwSc/edit#gid=1842403514&fvid=509446675)! We recommend that you regularly try to participate in contests organized by Codeforces and Codechef.

There are a lot of good resources available online — [https://github.com/lnishan/awesome-competitive-programming](https://github.com/lnishan/awesome-competitive-programming). This is a compilation of many popular free online resources with star ratings and all! Also, you need an efficient IDE setup to help you participate in contests. VS Code, Sublime Text, Atom, PyCharm are popular IDEs that you can choose from. If you haven’t set up your IDE yet, you may want to check out our blog that gives a detailed overview of the procedure of setting up an IDE.

Never be overwhelmed — There are a lot of things to learn in this wonderful journey! There is something called _rating_ on Codeforces just like FIDE ratings of chess. To put things into perspective, the best of the best guys of the globe out there like [**_tourist_**](https://codeforces.com/profile/tourist) have a rating of about 3700. Our senior, [Yash Chandnani](https://codeforces.com/profile/yashChandnani) (Y16), was leading from India until recently, at about a rating of 2700. They are all **red** coders! But hold on, there are only _9_ **red** coders all over India at Codeforces at present!

### Cyb3r-53cur17y: Digital Warfare

Hopefully, you could read that… It is _leetspeak_ for Cyber-Security. Maybe you have heard about _hacking, encryption, WEP/WPA, cryptography, cipher, SHA, RSA_ among a lot of other things? Well, this is the domain of programming where the goal is to learn how to communicate _securely_ and at the same time, learn about common loopholes that can be exploited by someone _evil_ and should be mitigated.

Do you see that padlock on the left of the address bar of your browser? Have you thought about what that stands for? Click on it —

It says that the connection is _secure_ and the **certificate** is _valid_. Now, what do you mean by secure?

A “secure” communication channel between two parties A and B in the context of cybersecurity refers to three things as I understand:

*   The message from A reaches _only_ B.
*   The message that B receives is _only_ from A.
*   Only that message which A has sent is received by B — Message is not tampered with.

This problem existed from that day when 2 cavemen wanted to communicate without their wives eavesdropping!

When Julius Caesar wanted to communicate with his generals in a battle, he would shift each letter in his message by 3. _“Send 5 legions to the north”_ became _“Vhqg 5 ohjlrqv wr wkh qruwk”_. Obviously, you understand nothing when you see it (unless you know the shift) and if you tamper with it, the “_unshifted”(decoded)_ message will not be meaningful. So, it is somewhat secure.

Some terminology in the example above — The original message is referred to as **_plaintext_** and shifted message is called **_ciphertext_**_,_ and the shifting procedure is the **_encryption_** algorithm here, and the value 3 here is the **_key_** _—_ it could have been any other number.

With the advent of digital computing and availability of GHz processors, lots of manual computation can now be done in under a second. Suppose, you didn’t know that how much the message is shifted with, but, you know that the algorithm used to convert the message to a _cipher_ is by some constant shift, you need to check just 25 possible cases, which is absolutely easy to check with the help of a computer (and manually too!). Checking every possible case is known as the **_brute-force_** technique in computer science.

![](/images/0__jZwIQPktdsgDhHI6.png)

Nowadays, we are surrounded by a lot of devices, and we use them for a greater part of our day. Naturally, there is a lot of information that is being collected by apps and devices to deliver better service. But, we don’t want that information to be public or readily accessible by anyone! It can range from our private photos to our nation’s nuke codes!

Cybersecurity can be broadly classified into two divisions — Theoretical and Practical. By theoretical, I mean **_cryptanalysis_** of encryption algorithms, where someone who completely knows and understands our algorithm, may recover the plaintext from the ciphertext without knowing the **_key_**_._ And by practical, I mean actually getting access to all the confidential information stored somewhere by exploiting **loopholes** in programs, source code and/or launching passive/offensive attacks.

Come on, if your crush asks you for the name of your first teacher during a conversation, you are likely to not think anything about it. But, if you have set the answer to that as your security question somewhere? People can impersonate someone else on Facebook and other social media and gain sensitive information by such a **_social-engineering_** attack.

![](/images/0__DHDVJE7GcN6KIW2Y.jpg)

Some websites may have _expressed disapproval_ when creating a weak password — because such passwords are common and easily broken by _dictionary-attacks_!

Now let me give some sources to learn further on the practical side:

*   [https://www.udemy.com/course/practical-ethical-hacking/](https://www.udemy.com/course/practical-ethical-hacking/)
*   [https://ctf101.org/](https://ctf101.org/)
*   [https://picoctf.org/](https://picoctf.org/)

Honestly, it is not very easy to jump into the theoretical part — it involves a good amount of math. But, here are some links you can definitely explore —

*   [https://www.tutorialspoint.com/cryptography/index.htm](https://www.tutorialspoint.com/cryptography/index.htm) — Must check out!
*   [https://pixelprivacy.com/resources/cryptography-guide/](https://pixelprivacy.com/resources/cryptography-guide/)
*   [https://www.coursera.org/learn/crypto](https://www.coursera.org/learn/crypto)

A simple task for you: (_Hint: learn how to use Google_)— YjQ1MzY0XzE1X24wN183MHU2aF9sMzM3Xw==

### **Web Development: Beginner’s Roadmap**

![](/images/1__xgtoIMef757C5RBnLXjhEA.gif)

Web development is the work involved in developing a web portal/ software for Internet users. Web-dev can range from developing a simple single static page of plain text(that’s how you kickstart things) to complex web-based internet applications (web apps), electronic businesses, and social network services.

![](/images/1__V__Jp13LvtVc2IiY2fp4qYw.jpeg)

Now, keeping the intro part aside, talking about some real stuff.  
Web-dev has two subdivisions: Frontend and Backend. Frontend revolves around building the User Interface (UI) and everything you’ll see on different applications or software, and constructing the interface between the user and the machine.  
Backend development, intuitively, handles the ‘behind-the-scenes’ functionality of software applications. It is more about connecting the webpage to a database, manage user connections, and power the application itself.  
Let’s explore a bit about the two fields:

**Frontend Development:** The most basic technologies you’ll need to have a grip on are HTML, CSS, and JavaScript. HTML (Hypertext Markup Language) will define the skeletal structure for your application. CSS(Cascading Style Sheet) describes the presentation of Web pages, including colors, layout, and fonts. Finally, JavaScript adds the logic part to the application and is responsible for establishing connections between the frontend and backend (somewhat).

![](/images/1__KRq7jQOUdQsHNsZa72XcDw.jpeg)

To get started with things, you can refer to these amazing resources:

*   [https://developer.mozilla.org/en-US/docs/Learn](https://developer.mozilla.org/en-US/docs/Learn)  
    This is a superb documentation by Mozilla and, in my view, the best resource to get started with web-dev. However, I feel MDN tutorials are of intermediate/advanced level.

For a more basic approach, you can refer to the below two resources:

*   [https://www.w3schools.com/html/](https://www.w3schools.com/html/)
*   [https://www.w3schools.com/css/](https://www.w3schools.com/css/)

After covering these subtle resources, maybe you could design your webpage and host it on IITK’s server (yes, you can do that too!).  
After learning these basics, move on to learn JavaScript _frameworks_ like [React JS](https://reactjs.org/) (for web applications) and [React Native](https://reactnative.dev/)(for mobile applications). The official documentation is quite extensive and is sufficient enough for learning these super popular technologies. You can simply follow the tutorials provided in the documentation and understand the workflow!

**Backend Development:** Backend is much more involving in comparison to frontend. Some of the famous technologies in this field are [Django](https://www.djangoproject.com/)( Python framework) and [NodeJS](https://nodejs.org/en/)( JavaScript framework). Obviously, for learning these frameworks, you need to have a good grip on Python and JavaScript, respectively. Now, backend comes in handy, mainly when you’re working on some web/mobile applications where you need to define specific functions that control things from backstage (google about “web API”).  
For learning Django, follow the tutorials on the official documentation, which would be good enough from the beginner’s perspective.  
For NodeJS, MDN docs are again pretty good! You can check them out [here](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs).

Well, if you think things were that simple, you might want to have a look at the flowchart below. It might scare you but believe me, it’s really cool!

![](/images/1__M7Wup__29RMUssCSuxKOSSQ.jpeg)

**_Where to test all this stuff you’ve learned?  
_**Open Source! Honestly, contributing to open source organizations was my motivation for learning web-Dev. Almost every organization has a minimum of two projects running, which involves web development. You can choose your organizations and start to work on the relevant issues!

**Bonus steps:** [FOSSASIA](https://fossasia.org/) runs its annual open-source fest [Codeheat](https://codeheat.org/). There are various projects for you to work on with some newbie issues too, which I believe any beginner can start working on irrespective of their knowledge and experience in the field.

### Machine Learning — Does a machine really learn?

When you hear about Machine Learning, all that strikes you is robots mimicking humans and virtual assistants getting closer and closer to humans every single moment. Well, these are certainly true, and innovation is occurring at a very rapid pace, but we shall start with the basics. One cannot jump to the top of the pyramid (does the top exist?) without climbing it step-by-step.

**Be Noted**: To understand the following section, you need to have some understanding of Basic Linear Algebra and Python. It is okay if you don’t understand this stuff yet. You can always come back to this blog later when you have the pre-requisite knowledge!

We shall first answer the main question in the first place — What is Machine Learning?

Machine Learning is a branch of Computer Science that recently emerged, which helps humans in doing human tasks, the simplest of them being the identification of objects. The list is quite endless; modern-day Machine Learning models can predict, classify, and even generate new data.

![](/images/1__q5Jj7MkR__1COI7AhAnO6lA.png)

Machine Learning models are mathematical models. Research in this field has occurred for a long time. Linear Regression was performed by Gauss (1809) to predict planetary movement. The field requires high computational power since millions of mathematical calculations take place before giving a useful output. Graphical Processing Units (GPUs), popularly known as Graphic cards emerged in the 21st century and were capable of handling calculations parallelly. This helped the field to prosper, and since then, there has been no stopping for groundbreaking research in ML.

The first thing a beginner should learn in Machine Learning is a [Linear Regression](https://en.wikipedia.org/wiki/Linear_regression) model. We suggest you learn the concepts as illustrated in the article. Now comes the implementation part.

For this, you will need Numpy and Matplotlib. Numpy is a matrix handling library in Python. Matplotlib will help you plot your 2-dimensional data, and you can use this for visualization. A good tutorial for Numpy can be found [here](https://numpy.org/devdocs/user/absolute_beginners.html). One for Matplotlib can be found [here](https://matplotlib.org/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py). Let us proceed forward.

Linear Regression data is available in plenty on the internet. If you are smart enough, you can make your own data (Hint:Use np.linspace, and introduce some randomness in the data). Use the ordinary least-squares loss function to optimize your model, and write a code for gradient descent which will minimize the least-squares loss function. Then create random data points (or linearly spaced data points :) ) and test how well your model has predicted using Matplotlib.

![](/images/1__QiU6DcP__r9qWLznMw0__M__Q.png)

Here is a bonus task for you. Try to figure out how this method of Linear Regression can be manipulated to solve for a polynomial of degree ’n’.

Feel free to ask any doubts about any secretaries. You may also refer to various blogs explaining how to write your first linear regression code. Take it this way: you have been given a problem statement, and you have to solve it in whatever way you can. All the best!

The links for the tutorials can be found here again —

1.  Linear Regression Wiki — [https://en.wikipedia.org/wiki/Linear\_regression](https://en.wikipedia.org/wiki/Linear_regression)
2.  NumPy tutorial — [https://numpy.org/devdocs/user/absolute\_beginners.html](https://numpy.org/devdocs/user/absolute_beginners.html)
3.  Matplotlib tutorial — [https://matplotlib.org/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py](https://matplotlib.org/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py)
4.  A nice walkthrough Linear Regression — [https://machinelearningmastery.com/linear-regression-for-machine-learning/](https://machinelearningmastery.com/linear-regression-for-machine-learning/)
5.  A Python implementation of Linear Regression — [https://towardsdatascience.com/linear-regression-using-python-b136c91bf0a2](https://towardsdatascience.com/linear-regression-using-python-b136c91bf0a2)

This blog post is a part of the Programming Club, IIT Kanpur blog series.